"""Utilities to write Robot-style output.xml from generic results."""
from __future__ import annotations

import logging  # https://docs.python.org/3/library/logging.html
from dataclasses import dataclass  # https://docs.python.org/3/library/dataclasses.html
from datetime import datetime, timezone  # https://docs.python.org/3/library/datetime.html
from typing import List, Optional  # https://docs.python.org/3/library/typing.html
import xml.etree.ElementTree as ET  # https://docs.python.org/3/library/xml.etree.elementtree.html

S_LOG_MSG_FORMAT = "%(asctime)s [%(levelname)-5.5s]  %(message)s"
logging.basicConfig(level=logging.INFO, format=S_LOG_MSG_FORMAT)
logger = logging.getLogger(__name__)


@dataclass
class TestResult:
    """Minimal test result model to serialize into Robot XML."""
    name: str
    status: str  # "PASS"|"FAIL"|"SKIP"
    start: datetime
    end: datetime
    message: Optional[str] = None
    tags: Optional[List[str]] = None


def _rf_timestamp(dt: datetime) -> str:
    """Convert datetime to Robot's 'YYYYMMDD HH:MM:SS.mmm' format."""
    logger.debug("_rf_timestamp(dt=%s)", dt)
    dt = dt.astimezone(timezone.utc).replace(tzinfo=None)
    return dt.strftime("%Y%m%d %H:%M:%S.%f")[:-3]


def write_robot_output(
    suite_name: str,
    tests: List[TestResult],
    out_file: str,
) -> None:
    """Write a Robot-style output.xml file for a single suite.

    Error handling: raises ValueError on empty suite; propagates IO errors.
    """
    logger.debug("write_robot_output(suite_name=%s, tests=%d, out_file=%s)",
                 suite_name, len(tests), out_file)
    if not tests:
        raise ValueError("No tests to write")

    generated = _rf_timestamp(datetime.utcnow())
    root = ET.Element(
        "robot",
        attrib={"generator": "robotic-adapter", "generated": generated}
    )

    suite = ET.SubElement(
        root,
        "suite",
        attrib={"name": suite_name},
    )

    # Suite start/end derive from first/last test
    start = min(t.start for t in tests)
    end = max(t.end for t in tests)

    # <doc> optional
    ET.SubElement(suite, "doc").text = f"Suite generated by robotic adapter for {suite_name}"

    # Body: tests
    for t in tests:
        test_el = ET.SubElement(suite, "test", attrib={"name": t.name})
        if t.tags:
            tags_el = ET.SubElement(test_el, "tags")
            for tag in t.tags:
                # No regex used; simple XML tag
                ET.SubElement(tags_el, "tag").text = tag
        # Robot puts setup/teardown/keywords in body; we omit for minimal schema
        status_el = ET.SubElement(
            test_el,
            "status",
            attrib={"status": "PASS" if t.status == "PASS" else "FAIL" if t.status == "FAIL" else "SKIP",
                    "starttime": _rf_timestamp(t.start),
                    "endtime": _rf_timestamp(t.end)}
        )
        if t.message:
            status_el.text = t.message

    # Suite status
    stats = {"PASS": 0, "FAIL": 0, "SKIP": 0}
    for t in tests:
        stats[t.status] = stats.get(t.status, 0) + 1

    suite_status = "PASS" if stats["FAIL"] == 0 else "FAIL"
    ET.SubElement(
        suite, "status",
        attrib={"status": suite_status,
                "starttime": _rf_timestamp(start),
                "endtime": _rf_timestamp(end)}
    )

    # <statistics> (very small summary to keep rebot happy)
    statistics = ET.SubElement(root, "statistics")
    total = ET.SubElement(statistics, "total")
    ET.SubElement(  total, "stat",
                    attrib={    "pass": str(stats["PASS"]),
                                "fail": str(stats["FAIL"]),
                                "skip": str(stats["SKIP"]),
                                "id": "s1",
                                "label": suite_name}).text = suite_name

    tree = ET.ElementTree(root)
    tree.write(out_file, encoding="UTF-8", xml_declaration=True)
    logger.info("Wrote Robot XML: %s", out_file)
